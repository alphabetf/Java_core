# JAVA核心



JAVA核心宗旨思想：**万物皆对象**

JAVA是**强类型语言**,即java对每一个具体的数据类型和大小都做了具体的划分

JAVA的数据类型：java中**只有有符号数据类型**

| byte              | 1字节     |
| ----------------- | --------- |
| **char, short**   | **2字节** |
| **int， float**   | **4字节** |
| **long， double** | **8字节** |

JAVA中	
	**整数**数字无论大小**默认**一律**int类型**
	**浮点数默认double类型**，如需要指定为float则需要在数字后加f标识,long类型数字后加l
	
java中**只允许**int float daouble进行运算:在java中日常整数运算只能用int类型或者大于int类型的
	由于计算机对int类型的运算相对高效，而处理溢出等行为相对耗费算力，降低效率，所以在java设计者看来，
	使用int类型以下的运算可能并没有那么复杂,没有必要做溢出检查，以此来牺牲效率，所以，
	**所有的int类型以下的数据或者变量运算前都会被提升为int类型后在运算**,
	而int类型及以上的数据运算则可能是需要进行一些复杂的运算，做溢出处理的之类的行为是必要的，在此情况效率不在是第一考虑因	素了

​	**但是 ++,-- +=,-=,/=,*=,%= 之类运算的操作则不会报错(这些操作java编译器内部会自动进行了强制类型转换)**

其他编程语言通用细节：	
	**取余运算**如果出现负数，**负数**只参考第一个，-5%2 = -1， 5%-2 = 1
	&&(逻辑与)与&（按位与）运算符的唯一区别是&&(逻辑与)会对第一个运算进行真假判断，以确定是否需要进行第二个计算->相对**效率**	更高
	在windows系统中回车符为\r\n,而在linux中为\n

JAVA中的类型转换与c语言的相似，``即:(目的类型)被转换的类型``	

JAVA中使用的是unicode编码，所以**变量名称是可以使用中文的**

在JAVA中**switch的限制**： 
	switch(x){} //x的可选类型：**byte char short int string**
	switch的实现机制只是查表，一旦查到符合预期的结果后将不在进行进行查表，所以如果没有break则程序会一直运行直到遇到break	或者switch语句结束
	break**只能**用于switch或者**循环语句**,否则编译报错，
	break默认跳出离自己最近一次的循环,在循环嵌套中,break如果想要跳出**指定的循环**,可以通过**标号**来实现,
	实现方式类似于go to语句，

```
例子：test1:for(;;){ 
		test2:for(){
        	break:test1 //跳到test1处执行
     	}
     }
```

​	continue语句只能作用于循环语句，**continue也能使用标号，直接跳转到标号**
​	
对于**for语句** ，其添加判断表达式部分如果为空（不写），则默认为true; for(;;)等效于while(true)	

在java中加号还有可能是连接符(**任何数和字符串相加结果都是字符串**)```例如："5+5=5"+5 =>字符串:"5+5=55"  ```
原因：在java中所有的字符串都是**字符串类对象**,类似于c++中重写字符串类的+号操作符实现连接符功能
		
java中的函数是定义在类中的,java中**没有**c++中的**操作符重载**特性

java支持**函数重载**：

​		要求：在同一个类中,同名函数,参数**类型**（void也是一种类型）或者**个数**不同，函数重载**与返回值类型无关**

java中没有类似于C++中的析构函数，当一个对象不在使用时（不在被任何对象引用时），java的垃圾回收机制会将内存其回收

JAVA**数组**：

在java中**数组的本质其实是一个对象**，所以在描述数组类型时长度不在考量范围内，创建数组也需要使用new来创建``例如：int[] arr = new int[3]; //此时arr可以看做为一个指针``

当使用arr[2]取值时，这其实是重载了[]的操作，该重载操作会对内存越界做检查，如果操作越界则会抛出异常

java的数组常见创建方式：

​	`` int[] arr = new int[] {1,2,3}，注意使用这种方式不能标明数组长度``

​	``int[] arr = {1,2,3}``说明，{1，2，3}这个在java官方名称为数组初始化器，当然也可以理解为没有类型的	匿名数组对象，其具体类型取决于接收它的数据的类型，如前面这种int[] arr = {1,2,3} 则{1，2，3}类型为int[]	类型 ``int[] arr = {1,2,3}``，这种操作的实现可以是如c++中的重载等号操作符，如发现两边都是数组对象，	则进行相应的赋值操作

**JAVA中二维数组：**

​	二维数组的本质是**每一个一维数组的每一个对象中在套一个一维数组**，只有最后那个一维数组所分配的空间里	面存储的是具体的数值，前一个维度里面的每一项存储的其实是指向那个最后的一维数组的地址的引用，引用	的默认初始化值为null

​	**二维数组初始化方式：**

​		 ```int[][] arr = new int[3][2]```

​		 ```	 int[][] arr = new int[3][](最后一个维度内存尚未分配，前一维度里面每一项指向的都是null)```
​		 ``int[][] arr = {{1,2},{1,2,3},{1,2,3,4}} ``注意如果使用初始化器进行初始化二维数组，必须按			 		 照这样的格式写，否则编译报错
**多维数组：**

​	此处要注意与C++不同，c++中多维数组的内存地址是连续的，而java中只有同一维度的数组的内存地址是连续	的，而且只有最后一个维度的内存空间里面存储的是实际数值，其他维度存储的皆为引用（也就是指向下一维	度的地址的引用）

java中堆内存创建后都会**默认初始化**:

​	int类型默认初始化为0，boolean类型默认初始化为false

​	float（0.0f）指针类型默认初始化为NULL, char（‘\u0000’）, 而**c++的堆内存则不会默认初始化**

**JAVA中没有指针的概念，取而代之的是引用**，如int[]（引用类型）就是指针（地址）的引用

JAVA中只有**基本数据类型**和类类型（也称为**引用类型**）

**JAVA中所有的关键字都是小写**

**C++中**的data区,也就是**全局**区,在程序开始执行前就确定了，比如c++的静态变量在**程序开始之前就已经在全局区分配好内存,无论你是否使用**（当然前提是参与了编译）
**JAVA中**的**全局**区，也称为方法区，与c++不同，其是在运行时动态改变的，如静态变量，会在**首次使用时在方法区分配内存并进行初始化**

java中类对象在创建完后，实际可以看为为指针，但是在使用时又会被转换为引用

​	`` car a1 = new car();car a2 = a1 这里的等于实际为指针变量的赋值操作，而不是实体对象的复制``

JAVA中的**this指针**使用**需要明确指示**，编译器并不会帮你自动隐式填充，

​	``如一个类中有成员变量a,成员函数 test(int a){ a = a} 这里的a全为局部变量 正确做法应该为 test(int a){this.a = a} ``

**this就是所属对象的引用，本质就是所属对象的指针的引用**

为减少代码复用性，JAVA中，在构造函数中可以用``”this(变量)“``这样的方式来调用自身的其他构造函数，且必须写在构造函数的**第一行**，否则编译报错（**只能在构造函数中调用自身的其他构造函数**）

**java中的构造函数无法在其他地方调用，简言之构造函数无法被再次调用**

静态成员函数只能使用静态成员变量（或者函数），因为静态是属于类而并非对象，**静态的本质其实就是定义的全局变量，只不过被限制到类中而已**

java中还有super指针，与this相似，this是对当前对象的引用，super指向当前对象的父类（也就是继承过来的那一部分）

静态函数不能使用this和super关键字，因为静态的函数或变量都不属于类

**JAVA中主函数必须是静态的**

**函数重载：**发生在同一个类中，返回值类型在考虑范围内
**覆盖（重写）：**发生在父子类中，与重载相似，但返回值类型也在考虑范围内

JAVA中有四种**权限修饰符**：

​	``public > protected > firendly(也就是默认的不写时的default) > private``
​	firendly这种称呼应该来源于c++,java中并没有这样的修饰符，这里这样称呼只是方便理解

java中有一个**替换原则**思想，”**即子类可以被当作父类使用**“，

​	所以在继承过程中，**子类的同名成员函数覆写（重写）的权限必须大于等于父类的权限**，否则就违反了这一原则。

C++中的final关键字（注意在c++中final关键字只能写在类名后或者成员函数或虚函数的圆括号后面）
C++中final关键字的作用是**禁止继承或覆写**,已提高代码的安全性
**C++中final关键字作用:**

​	1，被final关键字修饰的类，不能在被其他类继承
​	2，被final关键字修饰的成员函数或虚函数不能在被子类的同名函数覆写
java中的final关键字，功能基本与c++中的一致(**注意:与c++中不同java中final关键字是写在类名/函数/变量前面**)
**JAVA中final关键字的作用:**

​	1,被final关键字修饰的类，**不能在被其他类继承**
​	2,被final关键字修饰的函数，**不能被子类覆写**
​	3,被final关键字修饰的变量，**一旦被赋值就不能被在次修改，类似与常量**
​	4,被final修饰的引用变量，**不能再指向其他对象，类似于常指针**

java中final关键字修饰的变量是一个常量，只能赋值一次，且在定义时必须显示的给与明确赋值

在java中接口类可以继续继承或多继承于其他接口类,使用extends关键字
java中接口可以有私有方法，且有实现的函数体
java中**接口可以有默认方法**且可以有实现的函数体以允许接口提供某些默认行为，默认方法可以被覆盖或直接使用，``形式如下 public default void add(){...实现体...}``
java中**接口类不能有普通成员变量**，只能有public static final修饰的常量，即使不写，也会被隐式的加上
java中接口可以包含抽象方法，且不包含方法体，且是公开的
java中**接口可以定义静态方法**，静态方法有方法体且可以直接被接口调用，静态方法不被继承
java中没有包含如何方法和字段的接口被称为标记接口，感觉没啥作用，知道就行
**java中接口的方法默认都是public, 变量字段都是public static final的，即使你没有显示的指示，编译器也会隐式的给你加上**

**继承:**

​	java中并没有c++中的public继承， private继承， protect继承这样的说法，**java中只有extends来修饰继承**，	可以理解为只保留了c++中public继承这一种形式，也就是说所有的extends继承都是public继承

​	JAVA中继承是通过**关键字 extends**来实现的，而c++中是 :号

​	**java中只支持单继承，不支持多继承**

​	**C++中的菱形继承:**

​	C++中的菱形继承问题产生原因,由于C++支持多继承，所有继承的父类都会被整合到一个子类中的内存布局中，	当多个父类同时继承于同一个爷爷类时，则**子类的内存布局中就会存在两份完全一致的成员变量和成员函数**，	则在调用爷爷中的函数或变量时就会存在二义性问题

​	**C++中菱形继承解决：**

​	c++中为解决菱形继承问题，引入了**虚继承**，就是在继承类名前面添加一个virture关键字，虚继承底层的操作其	实就是编译器在编译时会**将继承体系中共同的父类成员或函数抽离出来一并放到子类内存地址的最后面**，说白	了，就是**共同部分只保留一份**

​	其实c++中的菱形继承中的成员函数可以通过改为虚函数来解决，但是成员变量不能用virture关键字来修饰，函	数可以，一旦添加了virture关键字，编译器就会抽调继承中所有的同名函数到虚函数表中，且只保留一份

​	java中的接口不允许定义普通成员变量，除了默认方法，**所有的变量和有实现体的函数其实都是静态属性的**，有	静态属性的是不能被覆写的，然而java中其他所有的函数都是有virture关键字隐式修饰的，所以即使java（接口	或者实现的）多继承中产生了菱形继承问题，virture关键字会抽取所有同名函数到虚函数表中，且虚函数表中	只保留一份，java以此方式完美的避开了c++中的菱形继承问题

​	java的接口多继承中如果出现了同名的”默认方法“（默认函数），则编译器会强制要求子类对该默认方法进行覆	写（重写），否则报错。

在c++与java中，**覆写是发生在父子类之间**，是函数名，参数列表，和返回值都完全一致才会产生覆写
在c++与java中，**重载是发送在同一个类中**，但是返回值并不在其考虑范围内

java中一个类在继承了另一个类的同时，还可以**实现多个接口**，（其实本质就是C++中的多继承）

**抽象类其实是抽取该体系中的基本共性内容，接口类就是是描述该体系的额外功能，这两个本质其实是相似的**

C++中是使用**类名加双冒号::**来实现精确的访问父类的变量和函数，但是java中是使用是**super().父类非静态成员或函数**，java中父类的静态成员不能使用super().来访问，必须通过类名来访问或者实列对象来调用

java中不支持**C++中的委托构造函数**（在同一个类中调用另一个构造函数）

​	委托构造函数语法：```构造函数：myclass():myclass(1){...}```

**JAVA中静态代码块**：就是在类中用static修饰的代码块：```static{...code...}，```只有在一个类被首次使用时，其static修饰的变量（或者	静态代码块）会开始被加载（分配内存并执行）到内存（ram）中，并一直存在直到程序彻底结束
**C++中类中的静态变量**是在程序开始运行前就已经在ram中被分配好内存了

**JAVA中的构建代码块**（**允许在每一个类构造函数执行前执行一段代码**），语法：在类中任意地方写 {。。。代码。。。}，

​	执行顺序：静态代码块（只第一次执行）->构造代码块（每次创建对象前都会被执行）->构造函数
**C++中不支持java中的构建代码块语法**

**类的构建顺序**:无论是在C++中还是JAVA中，一个类的构建顺序原则为”**先构建父类在构建子类**“

​	C++中:
​		:注意c++中的静态成员变量是在编译时就已经创建并分配好了空间，无论这个类是否使用，只要他参与了编译就是这样

​		在C++中一个类的详细**构建顺序**为：父类的静态成员变量->子类的静态成员变量->(:在程序执行之前静态的就已经存在并初始化好了)		父类的非静态成员变量初始化->父类的构造函数->子类的非静态成员变量的初始化->子类的构造函数

**C++多态底层实现原理：**

​	C++的每一个类在编译时就生成单独**属于这个类的vtable表**,包含继承来的类的，如果这个类或者这个类的继承	中有虚函数，**所有虚函数会被记录到这个vtable表中**，在这个**类**被创建时，编译器还会在类中添加一个**vptr指	针**变量

​	当一个子类有**继承**时，其所继承的类的所有的变量和函数必然会被编译器以一定的规范全部重新命名，然后整	合到当前构建的子类的内存布局中

​	当一个子类有继承并开始执行时，由于存在父类，这个子类vptr指针会先指向父类的vtable表，(然后传入当前	类的this指针)，然后开始执行父类成员变量初始化->父类的构造函数（**将父类的构造函数体直接隐式的插入到当	前行并执行**）-> 当父类的构造函数执行完后，子类的vptr指针会重新指向自身(子类)的vtable表。（注意：在编	译器一旦发现有虚函数或者继承体系中同名的虚函数被调用，则编译器会令其到vptr指针指向的vtable中查找该	函数地址并执行）

java中：
	java中类的静态成员变量只有在该类首次使用时被加载并分配内存的，这一点与c++中的策略有所不同

​	在java中一个类的详细**构建顺序**为：

​		父类的**静态成员变量**和**静态初始化块**->子类的静态成员变量和静态初始化块->父类的**非静态成员变量**和**非静态		初始化块**->父类的**构造代码块**->父类的**构造函数**->子类的非静态成员变量和非静态初始化块->子类的构造代码		块->子类的构造函数

**JAVA中多态的底层实现原理：**

​	JAVA与C++类似，在编译时会为**每一个类创建一个单独vtable虚函数表**，其中包含继承来的类，由于**JAVA中的	所有非静态成员函数默认都是虚函数**，所以必然也存在一个vptr指针，（除非类中不存在普通的成员函数，但是	**java中所有类都会最终继承于Object（上帝）类**，如果继承体系中最终没有继承于Object,编译器会隐式加上继	承Object）

​	与C++中类似，JAVA中当一个子类有继承时，其所继承的类的所有的变量和函数必然会被编译器以一定的规范全	部重新命名，然后整合到当前构建的子类的内存布局中

​	与c++不同，**JAVA中当一个子类被创建并开始执行时，其vptr指针就会坚定的指向本类自身（子类）的vtable	表**，所以即使在父类的构造函数中调用了被子类重写的同名虚函数，实际也会执行着子类的重写版本，因为所	有的虚函数都是通过vptr指针查找函数的。

​	可以理解为**编译器在子类的构造函数的第一行中隐式的插入了super(空)（或者说父类的空参数构造函数代码），当然如果你主动调用super(空或者非空参数)，则编译器不会主动帮你隐式插入父类构造函数代码**
（注意：在编译器一旦发现有虚函数或者继承体系中同名的虚函数被调用，则编译器会令其到vptr指针指向的vtable中查找该函数地址并执行）

注意，**无论是JAVA还是C++都不建议在构造函数中调用被覆写的函数**，因为此时类成员变量可能并未完成初始化，你得到的结果可能是非预期的，这不是一个很好的行为

**设计模式：**

单例模式，饿汉式

```java
class Single	/* 类一加载，就已经创建对象并在堆上分配了内存 */
{
	private static Single s = new Single();		/* 内部创建或者维护一个已经创建好的实例对象 */
	private Single(){}							/* private阻止创建实例对象 */
	public static Single getInstance(){return s;}	/* 提供获取实例的方法 */
}
```

单例模式：懒汉式（**在多线程情况下可能存在不唯一性**）

```java
class Single	/* 类加载时并没有在堆上分配内存 */
{
	private static Single s = null;
	private Single(){}
	public static Single getInstance(){	/* 获取实例对象时在创建对象 */
		if(s == null) s = new Single();	/* 类内部,有权访问类的私有属性 */
		return s;
	}
}
```

**C++中的引用：**

​	在日常使用中，可以这样认为：C++中的引用变量实际是不存在，只是一个临时别名，日常使用引用变量时，认为其是变量本身就可以了

**C++中引用的本质：**

​	C++的**引用的本质**可以看作是一个**常指针**，引用初始化时必须指定引用对象，一旦指向后就不能更改了，引用本质是指针，但是使用时	只需要当作实体来看就可以了，内部指针的传递与解引用编译器会自动帮你做好了，无需操心

C++中如果确认一个成员函数不会修改数据，则应该将该**函数定义为const属性**

​	做法就是在函数最后添加一个const修饰，`void add（）const {。。。}; `当一个类是const时，如果其调用的函数不是const类型则	 	编译器会报错

JAVA中：**instanceof关键字**:用于判断对象的具体类型，**只能用于引用数据类型**，``用法： if(a instanceof b){...}``

无论是JAVA还是C++,**普通成员变量并不会产生多态**，也就是类似于虚函数覆盖的那种,变量没有虚表

无论是JAVA还是C++,只有父子类都有的**同名函数虚函数**才会被编译器写入虚函数表，才会发生覆盖

**在JAVA中所有非静态类函数都是虚函数**，所以java中并没有C++中的virture关键字，因为不需要，所以java中只有覆写（重写）的概念，但是没有虚函数重写（遮盖）的概念

可以将java中所有默认的非静态函数看作为c++中的虚函数，c++中一旦遇见虚函数，就会将该函数地址抽调到虚函数指针所指的表中，所以会覆盖从父类继承过来的虚函数地址，所以最终形成多态

在java中非静态成员函数的覆写可以看作为c++中虚函数重写，java中静态成员函数的覆写，可以看作为c++中普通成员函数的覆写（准确的来说普通成员函数不存在覆写（重写），因为不存在类似于虚函数的表，所以应该理解为遮盖，隐藏，会更合理一些）

由于java中所有的非静态成员函数都默认是虚函数，所以父子类之间如果要产生静态成员函数的覆写（遮盖，隐藏），则父子类之间都必须是同名的都是静态的成员函数，否则编译时就会报无法被虚函数覆盖之类的错误

**静态绑定：**在编译时就已经确认了其调用的函数地址，表现在汇编上的语句就是 call 某某确定的地址，所有无法				   被覆写的（覆写：存在		vptr指针表的这种才能被覆写（重写），否则就是隐藏，遮盖）函数，都是				   静态绑定
**JAVA中以下状态会发生静态绑定**：1，静态函数，无法被覆写，只能被隐藏，所以在编译时就可以明确其地址
			    										   2，final关键字修饰的函数，无法被覆写
			    										   3，类的私有函数，继承后不可见，也无法被覆写
			   											4，初始化函数，如构造函数，**构造函数比较特殊有一定的静态属性**，但是构造																 函数属于对象，不属于类，所以构造函数又不能是静态的，但是尝试对构造																 函数覆写时会报错，“静态上下文无法引用非静态上下文之类的”

**动态绑定：**在运行时才确定其具体的地址的，在汇编层面上表现为call 某一个表中偏移地址，一般发生在存在vptr				   指针指向的虚函数表的覆写(重写),也就是多态的情况下
				   **动态绑定的前提是指针**(多态产生的条件之一,父类指针指向子类)，如果是实体，则无论如何都不会是动				   态绑定，因为实体对象在编译期间就可以确定其调用函数是哪个

**重载：**重载是发生在同一个类中的，且返回值不在重载的考量范围内，同一个类中同名函数，参数列表不一样的函			数可发生重载
**覆盖：**也可称为重写，参考C++最好的理解应该叫虚函数覆盖（重写），发生覆盖的条件除了了参数列表，连**返回			值也在其考量范围内**，其底层操作是根据参数列表和返回值特征，被编译成不同的函数名称，所以在发生			虚函数覆写时只有完全一致的函数才能产生虚函数覆写（重写）

**JAVA类的底层初始化过程：**

​		JAVA的继承关系中父类的构造函数会先被执行，原因是，在编译时编译器会默认在**子类构造函数中第一行添		加一个隐式语句 super();**，如果想调用父类的非空参数构造函数，需要在子类构造函数中主动调用非空参数		构造函数，``例如：super(int a);``
​		**super()语句必须在子类的构造函数的第一行**，因为父类的初始化动作应该先完成， **this()语句也只能放在第		一行**，所以super()与this()只能有一个，如果在子类的构造函数中使用了this()调用本类中的其他构造函数，则		当前构造函数中的super()则不存在了，但其他构造函数中肯定会存在隐式调用super()或者你主动调用的非空		参数的super(a)

​		**JAVA中的所有对象都隐式继承于Object**（java中的上帝）对象，即使不写extends Object，它也是隐式存在		的，所以，即使一个类没有继承任何对象，也可以调用super(); 可以理解为java中的所有类都有继承，所有类		的构造函数的第一行都会隐式存在一个super()语句，除非你主动调用了super(空或者非空参数)语句，否则编		译器就会隐式的给你加上

**多态的弊端：**前期定义的父类或者接口只能被子类重写，但父类或者接口却不能扩展

**抽象类与抽象方法：**
		类中方法**只有声明没有实现的方法就是抽象方法**，抽象方法返回值前面必须**被关键字abstract修饰**，含有抽		象方法的类,或继承抽象类但未全部实现抽象方法的类就是抽象类，抽象类也必须被abstract关键字修饰,抽象		类不能被实例化,抽象类是用来继承的,且子类只有重写了所有抽象函数后子类才能实例化,否则子类依然是一个		抽象类

​		**JAVA中的抽象类与c++中的纯虚函数功能一致，用于对外提供接口**

​		抽象类有构造函数，用于给**抽象类自己的子类**对象给抽象类中的字段进行初始化，**抽象类可以不定义抽象方		法，目的就是不让该类创造对象**,(一个普通类被abstract修饰后就不能用该类实例化对象了,但可以被继承)，一		般用于抽取一些共性属性和方法，这些共性被所有子类共享

​		JAVA中一个继承抽象类的子类如果没有完全实现父类的所有抽象方法，则这个子类也必须声明为抽象类，必		须使用abstract关键字修饰

​		**当一个抽象类中全部都是抽象方法,这个类就是接口**，这个类就不需要用class修饰，而是可以直接用interface		关键字修饰接口名称

​		JAVA中**接口中的成员都是有固定修饰符**的，即使不写，编译器也会隐式的加上，
​				1，全局常量：固定修饰符 public static final(JAVA规定)
​				2，抽象方法：固定修饰符 public abstract
​				结论：接口中的成员都是公有权限

**类与类之间是继承关系**：关键字是extends，**类与接口之间是实现关系**：关键字是implement 实现相对于继承只是描述的更加纯粹，如果实现没有完全重写所有的接口，则实现依然是一个抽象类

**静态变量和静态函数的底层原理：**

​		无论是C++还是JAVA其对于具有静态属性的变量和函数，其**存储方式必然是类似于虚函数表**，在某一处单独存		储着**静态变量和静态函数的静态表**，然后维护一个指针，指向该静态表，所以一个类的静态变量和静态函数		并不属于某一个对象，而是属于类，因为在该类的任何具体实例对象中，并不存在任何静态变量和静态函数		的实际内存，**该类的所有实例对象都存在着一个指向同一静态表的指针，当编译器发现这个类需要使用静态		变量或函数时，则会通过指针找到属于该类的静态变量或者函数**，每一个实例对象都会隐式的维护着一个静		态指针，指该类的静态函数和变量表,当这个类存在继承，且多次出现同一个类中的同名函数或者变量时（函		数名称或者变量名称在编译器底层必然会被依照一定规被修改）这里指的是菱形继承问题，完全同名的函数		或者变量（被编译器隐式修改后的名称）必然会被重写，类似于虚函数重写（注意：静态类的重写比普通继		承要严格，要不然多继承中**不同类的静态同名函数或变量**也会被重写，这是不合理的）

**C++中的友元和内部类：**（其实这两个是同一个东西）
		**友元函数和友元类，内部类其实都是具有静态属性的**（这里统称为友元），他们都**存储在一个类的静态存储		区之上**，但它们不属于这个类，却在这个类的作用域之上，简言之，友元能看到整个类的静态存储区（包括		类的静态函数和变量），而类却看不到友元的存在

​		编译器还给友元开辟了**特殊访问权限**，如：当给友元传入一个对象指针时，就可以通过该指针访问类的私有		变量，访问权限在此时开了特权，（正常情况下，在类的外部无法访问类的私有成员）
​		在**c++中友元函数和友元类没有权限修饰符**，但是内部类有public protect private权限修饰符
​		内部类在定义为public权限时，可以使用**外部类名::内部类名，来创建内部类对象**，
​		如果定义为protect或private则不能通过::来创建对象，这种访问权限并不会影响该类的继承，但是他会影响		到继承该类的子类是否能访问该内部类
​		内部类，友元函数，友元类由于存储在类的静态区之上，所以友元可以访问到外部类的static属性的成员或者		函数，**如需要访问外部类的私有属性，则需要想办法传入外部类对象指针**
​		内部类，友元函数，友元类由于存储在类的静态区之上，所以，在外部的类无法看到友元（内部类，友元函		数，友元类），**所以外部类无法访问友元**，
​		c++中的内部类还可以可以继承其他类，（被内部类继承过去的最终也会变成静态的属性）

**JAVA中的内部类：**
		**JAVA中没有友元的概念,只有内部类**，java中的内部类会被单独编译成一个.class文件,**文件名称为: 类名$内部		类名**,从这里可以看出，java将类本身和类的内部类当作两个普通的类来处理
		java中的内部类并非像c++中那样，天生就是静态属性的，**java中的内部类更像是一个类中的一个普通成员**，		可以被常见修饰符所修饰
		java中创建内部类对象的方式：Other.Inner in = new Other().new Inner();，由此可以知道在**创建内部类对象		时必然也创建了类对象**
		如果java中的**内部类中定义了静态属性的成员，则该内部类也必须被静态修饰符所修饰**，因为存在逻辑矛盾，		java中的静态属性成员从首次被使用时就会被分配内存并加载（c++中，从程序开始运行时就被分配内存并加		载），且**静态属性，属于类，无需创建对象就可以访问**如果内部类有静态成员则就可以通过 **外部类.内部类.静		态属性成员**这样的方式来直接访问，但是如果内部类本身是非静态属性的，则在**没有创建对象之前,内部类本		身是应该不存在的**，所以存在逻辑矛盾

**JAVA中内部类实现原理:**

​		JAVA编译器会将每一个内部类和外部类都单独编译成一个.class文件,

​		**每一个内部类都会持有一	"外部类名.this"指针"**，所以内部类可以访问外部类中的所有成员，但是外部类		却不能访问内部类的成员,外部类如果想要访问内部类，需要实例化内部类对象，通过对象来访问内部类

​		JAVA中**内部类可以存放在局部位置上**，也就是在类中的成员函数中定义并使用内部类,这种情况下内部类只		能访问局部中被final关键字修饰的局部变量,因为在局部的内部类被创建（new）后其地址可能会被返回被外		部使用，但是随着函数的运行结束，函数的局部变量也会消失，但是final关键字修饰的是常量，并不会消失,		可以继续被使用
​		JAVA中的**内部类是可以继续继承或者实现其他类**的，（把它当作一个普通类来看就可以了）
​		JAVA中的**匿名内部类的创建前提要求：必须继承或者实现一个外部类或者接口(可以为任意一个已经存在的		类或接口写一个内部类)**
​		JAVA中的**匿名内部类的格式：**``new 父类或接口(){子类内容} ``(规定书写格式，你也可以理解为这是在为一个类		添加一个临时的匿名内部类)，

​		**匿名内部类固定书写格式定义缘由：**因为子类是匿名的，无法new,只能找其父类或接口，父类或者接口中又		是抽象的，无法实例化（正常new出来的只能是父类），只能顺手写个花括号，将抽象类或者父类中的函数		覆写一下

​		**JAVA中匿名内部类的函数调用**:因为是匿名的所以无法通过正常方式调用，只能在创建的同时调用(用于临时		重写父类中的函数)，``如：new 父类或接口（）{子类内容}.匿名内部类重写的函数（）``；

```java
Object obj = new Object(){
	public void show(){
		...
	}；
}.show();	 /* 正常，当前类的类型依然是匿名子类对象类型，所以可以直接调用自己的成员函数 */
obj.show()；	/* 错误，obj类型已经完成转型，show函数并没有发生覆盖，并没有进虚函数表，所以对于obj来说，				当前找不到show()这个函数 */
```

在java中构造代码块比构造函数先执行，但是依然遵循着，父类先初始化这一原则，单从一个类来看，初始化默认成员变量先于>构造代码块先于>构造函数

java编译器会先检查语法错误并停止编译后报告，在检查逻辑错误在报告

#### JAVA中的异常：

​		**JAVA中异常的最终父类是Throwable类**，其下有两大子类Error类和Exception类
​		**JAVA中自定义的异常类必须继承throwable类异常体系，否则不具有可抛性**，无法被throws, throw这个两		个关键字操作,

​				throws, throw这两个关键字主要用于**操作继承于throwable类中的一个特殊函数，来达到跳转到指定的				catch语句中去继续执行**

​		**throw与throws的理解：**

​				throw:用于抛出异常用;

​				throws:用于声明可能抛出的异常类型,表示当前不处理，需要继续向上抛出异常

​		**JAVA中的异常类型：**

​				检查型异常：编译时就要求必须捕获处理该异常，或者继续向上抛出异常，也称为可处理异常，如										exception类及其子类

​				非检查型异常：也称为运行时异常，可以不继续向上抛，也可以不捕获，一旦触发立即停止程序运行，											也称为不可处理的异常一般是由jvm抛出的严重性的问题，如，ERROR类及其子类

​		JVM中的默认异常处理机制就是调用trowable类中printStaackTrace（）打印出异常信息

​		一个`try(){...}`可以对应多个`catch(){...}`,匹配规则是当异常发生时，会从上到下依次查找可以被匹配的		catch语句，一旦找到，其他catch语句就不会在被执行

​		如果一个父类的成员函数存在异常抛出，则在子类覆盖（重写）该成员函数时，只能抛出该父类抛出的异常		或者其异常的子类，或者不抛（简言之，**子类的重写函数只能抛出不大于父类中抛出的异常**），这是java的强		制规定，为了确保程序的健壮性

**JAVA中的异常实现机制：**
		1，**Throwable类中必然存在一个特殊函数**，被RuntimeExceptions和Errors类所重写，该函数中必然存在一		个类似于操作PC（go to）指针的操作,将异常参数（压入栈中）和PC指针指向离其最近（在调用体系中）的		catch()函数中。当遇到throw关键字时，编译器内部会隐式的这样操作
		2，**throws关键字其中的一个作用其实是声明**，当然这也通知编译器遇到不要报错，因为类文件是单个单个		编译的，异常类与使用抛出异常的类不是同一个.class文件，声明很重要,使用throws关键字进行特殊声明
  	 throws关键字应该还有一个功能，就是在调用体系中查找最近的catch语句地址，并影响前面说的PC指针的地		址，（RuntimeExceptions类应该有默认跳转地址）即使是RuntimeExceptions类被throws声明，跳转指针		也会指向最近的catch语句处，而不是jvm默认地址
		3，非检查型异常，主要是RuntimeExceptions和Errors类及其子类，该语法现象的主要原因是						       		**RuntimeExceptions和Errors类重写了Throwable类中的那个函数**，当异常抛出时，直接隐式插入jvm的错		误异常处理函数，让程序直接停止运行，至于为什么不需要使用throws关键字进行声明，可能是编译器提前		进行了隐式声明（编译器特殊待遇）
		4，**try finally组合，finally语句块一定会被执行**，一般用于释放资源

JAVA中，包与包之间的类进行访问，被访问的包中的类必须是public,被访问的类中的方法也必须是public,这		是规则
package 包名， package关键字**指定该类所属的包**
import 包名的类，**导入某包中的指定的类**（只导入包中的类，不导入包中的包），import的主要作用是用于		简化类名书写
**jar:java的压缩包**，就是将编译好的包（一堆.class文件）归档为一个jar文件包，其实就是打成压缩包

**synchronized关键字：**

​		`synchronize(obj){...} `该形式称为**同步代码块**, synchronize写在函数中称为**同步函数**，
​		synchronized(obj)中的obj称为**锁对象**，是用于标记同步锁的（可以理解为类似于**同步锁的名称**），普通同步		函数中默认的同步锁对象为调用他的对象，静态函数的默认同步锁对象为该类的运行时对象（即，类名.class		或者类对象.getClass()）

**多线程中的wait()与notify()原理：**
		当一个synchronized同步块被创建使用时，其内部必然存在两个基于该同步块对象的元素，一个是**锁标志**，		一个是**挂起线程队列**，当线程进入同步块时首先会检查锁标志是否被占用，如果锁标志未被占用则，则占用		锁，后继续执行代码，直到出同步块后释放锁,如果锁被占用，则将当前线程挂入就绪队列中，也就是发起切		换线程，重新发起调度，

​		**wait()与notify()的调用必然要在同步函数或者同步代码块中**，否则无法找到基于对象锁的挂起线程队列。就		无法明确挂起或恢复哪一个线程
​		当wait（）被调用时，则先会释放当前对象持有的锁标志，然后将当前线程挂入当前对象锁的挂起队列中，
​		当notify（）被调用时，则会随机从当前对象的挂起队列中抓取一个已经被挂起的线程放入到就绪队列中，等		待执行
​		说明：当一个被挂起的线程被唤醒后，会从wait()处返回并继续向下执行，该线程理应重新参与竞争锁，因为		他当前没有锁，不应该能继续执行

​		java中更好的lock接口：本质就是**将锁标志和挂起线程进行分离** 

​			`	Lock lock = new ReentranLock（）`用于创建一个锁, lock.lock（）获取锁 ,lock.unlock（）释放锁，对			于会抛出异常的情况下lock.unlock（）通常放置在finaly代码块中
​		    `Condition con = lock.newCondition()`创建并返回一个新的挂起队列, con.await()将当前线程挂入con			挂起队列中, con.signal()从con这个挂起队列中随机唤醒一个线程
​		wait()与sleep()的区别，wait()可以指定时间也可以不指定，但sleep()必须指定

​	 （一般线程类）类.interrupt(),清除中断状态标志位，用于强制唤醒已经被挂起的线程，但是会抛出中断异常，		因为该线程是被强制唤醒的

java中的**字符串常量池**，当使用字符串初始化字符串变量（对象）时，字符串常量池中没有该字符串对象就会建立，否则直接使用字符串常量池中的字符串对象

在java中没有指针，所以“abc”这样的类型应该会被编译器认为是字符串对象，而不是c++中是char*类型

java中string类重写了object中的equals()函数，比较的不在是地址，而是字符串的内容值

**JAVA中的自动装箱与拆箱：**

​		当使用**基本数据类型赋值给引用数据类型**时，编译器会自动在临时区**创建一个对象**并赋值

​		如：`void add(object num); add（6）`；当使用num时又会被自动拆箱，简言之，你可以把他当成一个数		字使用即可

**JAVA中的泛型：**

​		为了兼容之前的JAVA版本，JAVA的泛型采用**泛型擦除**来实现泛型,这意味着泛型信息只在编译阶段存在，用于类型检查和类型推断,一旦代码被编译，所有的泛型类型参数都会被擦除，替换为它们的边界类型（如 `Object`）或原生类型(这里理解为替换成object类型就可以了)

**JAVA中的泛型只能是引用数据类型，不能是基本数据类型：**

​		原因：1，性能下降（主要原因）：如果泛型支持频繁的装箱和拆箱会增加垃圾回收的压力，降低程序的执行																	效率，特别是在大量处理基本类型数据的场景中

​					2，复杂性增加：编译器和运行时环境需要处理更多的转换逻辑，增加了实现的复杂性

​					3，一致性问题：在泛型代码中混合使用基本类型和引用类型可能导致代码的可读性和一致性降低

`public <W> void show(w str){...} `这种写法是将泛型定义在方法上，在使用时w将自动匹配为传入的参数类型，注意：这种泛型<>必须放在返回值的前面，修饰符的后面

java泛型上下限：
？extends E ->:接收E类型或者E的子类对象（上限）
？ super E ->:接收E类型或者E的父类对象（下限）

**增强for(类型 变量：Collection集合|数组){...}**

函数的可变参数，`int... arr`**其实就是数组元素,用传入参数来初始化数组**，必须定义在参数列表的结尾
**静态导入：**`import static java.lang.System.* `导入类中的静态成员（函数和变量）：
		可以理解为编译器将类中的静态成员函数或者变量抽离出来，并**在import处进行了声明**，所以在下面代码中		可以直接使用

**JAVA中的反射机制：**

​		java中的所以类都会被进一步抽像描述为成一个Class类(可以理解为所有的类都是以该Class类为原型模板创		建的)，通过该Class可以获取到该类中的所有属性和方法，即使是私有的也可以获取，和使用
​		**获取字节码对象的方式（Class类对象）：**

​				1，通过object中的getClass()方法获取,该方法需要创建对象
​				2，任何类型（包括基本数据类型）都具备一个静态属性.class，可通过类名.class来获取Class对象，需					  要类名
​				3，使用Class类中的静态方法forName()来完成，只需要传入类名的字符串名称即可
​		可以理解为Class是所有类型，包括基本数据类型的进一步的抽象描述，所有的类型都会被抽象出一个Class，		并用这个Class类来创建一个又一个对象，Class类中包含了对这个类的所有描述

